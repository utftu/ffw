# Библиотеки для работы с формами в React приложении

### Что такое библиотека для работы с формами?
Это библиотека, которая обеспечивает обновление состояния react приложения в зависимости от 
введенных пользователем данных

### Что значит `обеспечивает обновления состояния`?
Когда пользователь вводит какие-то данные в `<input/>` библиотека реагирует на их под и оповещает о введенных данных 
остальные части react-приложения. По сути библиотека передает в input собственные value и onChange, чтобы контролировать состояние компонента

### Так в чем проблема
Есть два подхода к механизму подписки:
1. Оповещение всех компонентов которые используют какие-либо данные из этой формы (глобальная подписка)
2. Оповещение элементов использующих только те данные которые изменились (подписка на определенные поля формы)

Вариант с глобальной подпиской более простой в реализации и использовании, вариант с подпиской на определенные 
поля более производительный, поскольку не заставляет обновлять компоненты без необходимости. 
Эти подходы напоминают redux(имеет глобальную подписку) и mobx(подписывается на изменения определенных переменных).

Если в данных момент будете выбирать библиотеку для работы с формами, то заметите что большинство библиотек реализуют 
глобальную подписку(formik, final-form). Это неплохой подход, который однако увеличивает число обновлений компонентов и это узким местом, 
когда на странице находится множество полей. Получается что вводя какой-либо символ в input, мы обновляем все наше react 
дерево, вероятно по нескольку раз.

Механизм подписки реализован в данный момент в относительно небольшом количестве библиотек(react-hook-form,
mobx-react-form). Каждая из известных мне библиотек этого типа имеет изъян, который не позволяет использовать ее. 
Для примера mobx-react-form зависит от mobx и не может работать без него, react-hook-form имеет неточную документацию, 
неудобный api для множественной подписки и самое главное механизм работы с input-ами по средствам 
работы напрямую с DOM-узлами(по сути инпуты становятся stateless, что ведет к множеству багов). 

По итогам я не нашел библиотеку, которая реализовывала частичную подписку и была бы достаточная удобна в использовании api.

### Давайте представим!
Давай теперь представим что ни одна существующая библиотека нам не подходит и мы решили написать свою, какой она должна быть?

1. Она должна реализовывать частичные подписки
2. Она должна иметь удобное api, которое по возможности похоже на самые популярные библиотеки(formik, final-form) 

В обои случаях мы как-правило получаем данные примерно так

(здесь и далее примеры из formik-a, в примерах для final-form нет необходимости, поскольку он предоставляет похожий api)
```tsx
const [nameField] = useField('name')
```
Здесь все достаточно понятно, по-средствам useField мы подписываемся на изменения формы и получаем данные поля. 
В случае formik-a мы подписываемся не конкретное поле, но поскольку useField имеет имя поля 'name', он может реализовать частичную подписку.
Реализуем ее на стороне библиотеки, поскольку react context не умеет частично обновлять зависимости

При этом кажется отказаться от необходимости деструктуризации данных. В случае formik-a получения всех данных о поле будет выглядеть вот так:
```tsx
const [nameField, nameMeta, nameHelpers] = useField('name')

return (
  <div>
    <input{...nameField}/>
    <div>{nameMeta.error}</div>
    <button 
      onClick={() => {
        nameHelpers.setValue('')
      }}
    >
      clear field
    </button>
  </div>
)
```

Однако деструктуризация заставляет писать нас больше кода и следить за тем получили 
ли мы из деструктуризации необходимое нам свойство поля, сделаем так, чтобы useField возвращал объект со всеми этими свойствами
```tsx
const nameField = useField('name')

return (
  <div>
    <input{...nameField.getInputProps()}/>
    <div>{nameField.error}</div>
    <button 
      onClick={() => {
        nameField.set('')
      }}
    >
      clear field
    </button>
  </div>
)
```
(здесь использован метод `getInputProps()`, поскольку как кажется, он лучше описывает то что происходит 
при передаче данных в input и дает возможность использовать `getSelectProps()`, которые передает данные по другому и не рассмотрен здесь)

В целом улучшения незначительные, но с ростом количества используемых полей положительный эффект становится заметней:

formik
```tsx
const [nameField, nameMeta, nameHelpers] = useField('name')
const [ageField, ageMeta, ageHelpers] = useField('age')
const [addressField, addressMeta, adressHelpers] = useField('address')
const [favoriteGameField, favoriteGameMeta, favoriteGameHelpers] = useField('favoriteGame')
const [bankAccontField, bankAccontMeta, bankAccontHelpers] = useField('bankAccont')
```

Новая библиотека:
```tsx
const nameField = useField('name')
const ageField = useField('age')
const addressField = useField('address')
const favoriteGameField = useField('favoriteGame')
const bankAccontField = useField('bankAccont')
```
Представьте сколько времени можно потратить на написание и отслеживание использование полей в старой версии. 

useField возвращает сущность, а как работать с данными глобально?

formik имеет свойства и методы
* `setValues()`
* `setErrors()`
* `setTouched()`
* `setFieldValue()`
* `setFieldError()`
* `setFieldTouched()`
* `values`
* `errors`
* `touched`

Сделаем похожее api
* `setValues()`
* `setErrors()`
* `setTouches()`
* `setValue()`
* `setError()`
* `setTouched()`
* `values`
* `errors`
* `touches`

(изменено слово touched на слово touches, что отражает множественное число, убрана лишнее упоминание Field)

formik имеет удобный механизм работы с валидацией, сделаем такой-же в новой библиотеке:
```tsx
const form = useForm({
  validateSchema: yup.object({
    name: yup.string().required()
  })
})
```

Кажется все готово. Как было и даже лучше, с частичной подпиской

### Авторский улучшения



Для начала определимся с терминами:


Если в сервисе немного форм - вам повезло. Если нет - приятного прочтения.

### Существующие решения:
Раньше все ходили с бумбоксом на плече и использовали формы интегрированные со state manager-ом. Эти времена прошли и 
оставили нам твердую уверенность, что формы это что-то особенное и локальное, что не должно хранить данные в 
глобальном и по-хорошему не зависеть от конкретного state manager-a. Не будет рассуждать почему это хорошо, а посмотрим 
кто пришел на смену великому redux-form.

Решения, которые имеют больше всего звезд или у всех на слуху:
* formik
* react-hook-form

(субъективно)

Что с ними не так:

#### formik
Самое популярное решение и небезосновательно. Большую часть статьи будет уделено именно сравнению с ним. 
Не могу сказать о других разработчиков, но эта мое сердце он завоевал своей простой и безотказностью.
Все сделано максимально просто и максимально непроизводительно. При обновлении любого поля обновятся все компоненты 
которые используют formik. Кажется это стоит исправить

Pros:
* Удобное и интуитивно понятное api

Cons:
* Глобальные изменения и отсутствие механизма подписки на конкретное поле

#### react-hook-form
Относительная новая библиотека. В ней решена проблема глобального обновления подписанных компонентов, 
но привнесены другие проблемы:

Pros:
* Производительный механизм на определенное поле 

Cons:
* Использование stateless полей по средствам хранения в форме dom-представления поля, вместо его значения. 
Это решение довольно производительно, но при этом этот подход забирает контроль над данными.
* Неудобное api и плохая документация. Очень субъективный пункт, но можете попробовать подписаться на 
изменения свойства touched для конкретного поля. Довольно сомнительное удовольствие.

Попробуем взять все самое лучшее:
* Механизм подписок на конкретные поля. Это залог производительности формы
* Удобное api, по возможности максимально совместимую с formik-ом.

Механизм подписок
Как он должен выглядеть? Первые мысли что он должен выглядеть вот так:
```js
const [nameField] = useField('name')
```
Довольно просто! После того как подписался на поле можно использовать значение из переменной.

Но часто нужно получить не только само поле, но и его мета-информация и хелперы для обновления значения. 
У formik-a это выглядит так:
```js
const [nameField, nameMeta, nameHelpers] = useField('name')
const [ageField, ageMeta, ageHelpers] = useField('age')
const [addressField, addressMeta, adressHelpers] = useField('address')
```
Довольно многословно, и это только для 3 полей! Значит можно подумать о другом api подписки. В своей практики я 
заметил что удобно работать с глобальным объектом формы, часто возникает необходимость поменять разные значения 
и не хочется вспоминать лежат они nameFieldMeta или nameField, проверять получены ли они уже с помощью деструктуризации.
Попробуем посмотреть как может выглядеть подписка в таком случае:
```js
const form = useForm('name', 'age', 'address')
```
Кажется получилось довольно лаконично
