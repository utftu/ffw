# React формы, библиотека для частичной подписки

### Что такое библиотека для работы с формами?

Это библиотека, которая обеспечивает обновление состояния react приложения в
зависимости от введенных пользователем данных

### Что значит `обеспечивает обновления состояния`?

Когда пользователь вводит какие-то данные в `<input/>`, библиотека сохраняет
новые данные и оповещает о введенных данных остальные части react-приложения. По
сути библиотека передает в input собственные value и onChange, чтобы
контролировать состояние компонента

### Так в чем проблема

Есть два подхода к механизму подписки:

1. Оповещение всех компонентов, которые используют какие-либо данные из этой
   формы (глобальная подписка)
2. Оповещение элементов использующих только те поля, которые изменились
   (частичная подписка)

Вариант с глобальной подпиской более простой в реализации и использовании,
вариант с подпиской на определенные поля более производительный, поскольку не
заставляет обновлять компоненты без необходимости. Эти подходы напоминают
redux(имеет глобальную подписку) и mobx(подписывается на изменения определенных
переменных).

Если вы будете выбирать библиотеку для работы с формами, то заметите что
большинство библиотек реализуют глобальную подписку(formik, final-form). Это
простой подход, который, однако, увеличивает число обновлений компонентов. Для
приложения с большим количеством полей на странице это становится узким местом.
Получается что вводя какой-либо символ в input, мы обновляем все наше react
дерево(иногда несколько раз).

Механизм частичной подписки реализован в данный момент в относительно небольшом
количестве библиотек(react-hook-form, mobx-react-form). Каждая из известных мне
библиотек этого типа имеет изъян, который не позволяет использовать ее. Для
примера mobx-react-form зависит от mobx и не может работать без него,
react-hook-form имеет неточную документацию, неудобный api для множественной
подписки и самое главное механизм работы с input-ами по средствам работы
напрямую с DOM-узлами(по сути инпуты становятся stateless, что ведет к множеству
багов).

По итогам я не нашел библиотеку, которая реализовывала частичную подписку и была
бы достаточно удобна в использовании api.

### Давайте представим!

Теперь представим что ни одна существующая библиотека нам не подходит и мы
решили написать свою, какой она должна быть?

1. Она должна реализовывать частичные подписки
2. Она должна иметь удобное api, схожее с популярными библиотеками(для меня это
   formik)
3. Она должна быть интегрирована с популярными средствами валидации

И в formik-е мы работаем с данными примерно так:

```tsx
const [nameField] = useField('name');
```

Здесь все достаточно понятно, по-средствам useField мы подписываемся на
изменения формы и получаем данные поля. В случае formik-a мы подписываемся не
конкретное поле, на любое изменение в форме, получая при этом значение для
конкретного поля. Но поскольку useField имеет имя поля в качестве параметра, он
может реализовать частичную подписку. Реализуем механизм подписки на стороне
библиотеки, поскольку react context не умеет частично обновлять зависимости

При этом кажется можно отказаться от необходимости деструктуризации данных. В
случае formik-a получения всех данных о поле будет выглядеть вот так:

```tsx
const [nameField, nameMeta, nameHelpers] = useField('name');

return (
  <div>
    <input {...nameField} />
    <div>{nameMeta.error}</div>
    <button
      onClick={() => {
        nameHelpers.setValue('');
      }}
    >
      clear field
    </button>
  </div>
);
```

Однако деструктуризация заставляет писать нас больше кода и следить за тем
получили ли мы из деструктуризации необходимое нам свойство поля, сделаем так,
чтобы useField возвращал объект со всеми этими свойствами

```tsx
const nameField = useField('name');

return (
  <div>
    <input {...nameField.getInputProps()} />
    <div>{nameField.error}</div>
    <button
      onClick={() => {
        nameField.set('');
      }}
    >
      clear field
    </button>
  </div>
);
```

(здесь использован метод `getInputProps()`, поскольку как кажется, он лучше
описывает то что происходит при передаче данных в input и дает возможность
использовать `getSelectProps()`, которые передает данные по другому)

В целом улучшения незначительные, но с ростом количества используемых полей
положительный эффект становится заметней:

formik

```tsx
const [nameField, nameMeta, nameHelpers] = useField('name');
const [ageField, ageMeta, ageHelpers] = useField('age');
const [addressField, addressMeta, adressHelpers] = useField('address');
const [favoriteGameField, favoriteGameMeta, favoriteGameHelpers] =
  useField('favoriteGame');
const [bankAccontField, bankAccontMeta, bankAccontHelpers] =
  useField('bankAccont');
```

Новая библиотека:

```tsx
const nameField = useField('name');
const ageField = useField('age');
const addressField = useField('address');
const favoriteGameField = useField('favoriteGame');
const bankAccontField = useField('bankAccont');
```

Представьте сколько времени можно потратить на написание и отслеживание
использование полей в версии formik-a.

useField возвращает сущность, а как работать с данными глобально?

formik имеет свойства и методы для самой формы

- `setValues()`
- `setErrors()`
- `setTouched()`
- `setFieldValue()`
- `setFieldError()`
- `setFieldTouched()`
- `values`
- `errors`
- `touched`

Сделаем похожее api

- `setValues()`
- `setErrors()`
- `setTouches()`
- `setValue()`
- `setError()`
- `setTouched()`
- `values`
- `errors`
- `touches`

(изменено слово touched на слово touches, что отражает множественное число,
убрано лишнее упоминание Field)

И последнее, валидация. Formik имеет удобный механизм работы с валидацией(yup),
сделаем просто такой-же в новой библиотеке:

```tsx
const form = useForm({
  validateSchema: yup.object({
    name: yup.string().required(),
  }),
});
```

Так же в дополнение к этому можно добавить использование unstable_batchedUpdates
внутри библиотеки для повышение производительности

Кажется все готово. Как было и даже лучше, с частичной подпиской

### Авторский улучшения

Но когда начал что-то менять сложно остановиться, и вот несколько улучшений,
которые хотел бы добавить я:

В formik-е нет деления на логические сущности и все методы исходят именно из
этого. Так, например, чтобы выставление несколько свойств для одного поля в
formik-е будет выглядеть вот так

```tsx
form.setFieldValue('name', 'xXx');
form.setFieldError('name', 'too hot');
form.setFieldTouched('name', true);
```

А при наличии отдельной структуры Field, может выглядеть вот так:

```tsx
const nameField = form.fields.name;
nameField.set('xXx');
nameField.setError('too hot');
nameField.setTouched(true);
```

Кажется неплохое улучшение, исчезает необходимость писать название поля
несколько раз.

#### Есть два типа людей

Любое множество можно разделить на две части по средствам "не". Вот и я, автор,
один из тех людей, кто не любит лишний раз доставать значение из сущности в
отдельную переменную. Следующий подраздел о для таких людей как я и никак не
влияет на правильность рассуждений, которые были до этого.

Как можно упросить этот код?

```tsx
const nameField = useField('name');
const ageField = useField('age');
const addressField = useField('address');
const favoriteGameField = useField('favoriteGame');
const bankAccontField = useField('bankAccont');
```

Довольно просто, не доставать значения из переменных, а работать напрямую с
формой

```tsx
const form = useForm('name', 'age', 'address', 'favoriteGame', 'bankAccont');
```

Насколько это удобно каждый решает сам, но лично для меня намного удобней
подписываться на форму с помощью механизма глобальной формы

```tsx
const form = useForm('name');

return <input {...form.fields.name.getInputProps()} />;
```

#### Немного безопасности

Когда работаешь с глобальной формой велик риск изменить поле на которое ты не
подписан. Для этого в нашей воображаемой библиотеки, в режиме разработки, должен
быть proxy объект, который будет замещать форму. Он будет отслеживать изменения
и оповещать о попытки изменения поля, в компоненте который на это поле не
подписан.

```tsx
const form = useForm('name');

return <button onClick={() => form.fields.age.set('')}>clear name</button>;
```

В данном случае в режиме разработки мы получим ошибку<br>
`You don't have access to field - name`

#### Пару слов о синхронности

Что будет находиться в значении поля name, если написать такой код для formik-а?

```ts
formik.setFieldValue('name', 'robbin');
console.log(formik.values.name); // previous name
```

Правильный ответ - значение, которое находилось в name до вызова setFieldValue.
Это нельзя назвать явной ошибкой, как минимум такой подход используется в
react-е, однако на мой взгляд это не самое очевидно поведение и другое поведение
было бы логичней

```ts
formik.setFieldValue('name', 'robbin');
console.log(formik.values.name); // robbin
```

### В итоге

Соберем все вместе!

```js
// app.js
function App() {
  const form = useInitNewForm({
    validateSchema: yup.object({
      name: yup.string().required(),
      age: yup.number().required(),
    }),
  });
  return (
    <NewFormProvider value={form}>
      <div>
        <Name />
        <Age />
      </div>
    </NewFormProvider>
  );
}

// name.js
function Name() {
  const form = useForm('name');
  return <inout {...form.fields.name.getInputProps()} />;
}

// age.js
function Age() {
  const ageField = useField('age');
  return <inout {...fageField.getInputProps()} />;
}
```
